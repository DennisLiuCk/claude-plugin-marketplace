---
name: issue-review
description: |
  系統化的問題分析專家技能，協調三個專門代理進行深度問題分析，從問題描述到根本原因定位的完整工作流程。

  適用於分析各種來源的問題：
  - 使用者或 PM 報告的線上問題
  - 開發團隊反映的技術問題
  - 測試發現的 bug
  - 生產環境告警和異常

  這個技能會自動協調以下代理：
  - problem-analyzer：分析問題描述，制定調查方向
  - codebase-investigator：調查程式碼庫，找出可能原因
  - root-cause-finder：深入驗證假設，定位根本原因
---

# Issue Review - 系統化問題分析工作流程

你現在進入了 **Issue Review** 模式，這是一個系統化的問題分析工作流程，幫助你從不完整的問題描述開始，逐步深入分析，最終定位到問題的根本原因。

## 🎯 工作流程概覽

```
階段 1: 問題分析 (problem-analyzer)
   ↓
階段 2: 程式碼庫調查 (codebase-investigator)
   ↓
階段 3: 根本原因定位 (root-cause-finder) [迭代]
   ↓
階段 4: [可選] 驗證測試
   ↓
階段 5: 最終報告
```

## 📋 工作流程詳解

### 階段 1：問題分析 (Problem Analysis)

**目標**：理解問題，制定調查方向

**執行方式**：
```
啟動 problem-analyzer 代理，傳入使用者提供的問題描述
```

**代理工作**：
1. 提取問題資訊（現象、環境、重現步驟等）
2. 識別資訊缺口
3. 分類問題（類型、嚴重程度、緊急程度）
4. 提出初步假設（按可能性排序）
5. 制定調查方向

**輸出**：
- 結構化的問題分析報告
- 3-5 個初步假設（附可能性評估）
- 技術調查清單

**用戶交互**：
- 如果資訊嚴重缺失，詢問使用者是否能提供更多資訊
- 展示分析結果，確認理解正確

---

### 階段 2：程式碼庫調查 (Codebase Investigation)

**目標**：定位相關程式碼，識別所有可能原因

**執行方式**：
```
啟動 codebase-investigator 代理，傳入 problem-analyzer 的分析結果
```

**代理工作**：
1. 定位進入點（API、事件處理器）
2. 追蹤執行流程（前端 + 後端）
3. 識別潛在問題點（7-10 個位置）
4. 為每個可能原因評分（0-100）
5. 按可能性排序

**輸出**：
- 程式碼地圖（關鍵檔案和進入點）
- 完整執行流程圖（標註問題點）
- 5-7 個可能原因（附詳細評分）
- 程式碼片段和行號

**用戶交互**：
- 展示調查結果
- 說明找到 X 個可能原因
- 說明接下來將從最高可能性開始驗證

---

### 階段 3：根本原因定位 (Root Cause Finding) [迭代階段]

**目標**：深入驗證假設，找到確定的根本原因

**執行方式**（迭代）：
```
對於每個假設（從最高可能性開始）：
  啟動 root-cause-finder 代理，深入分析該假設

  如果結果 = "確認" (Root Cause Found)：
    → 進入階段 4

  如果結果 = "部分確認" (Probable Cause)：
    → 記錄需要更多資訊
    → 繼續分析下一個假設

  如果結果 = "排除" (Ruled Out)：
    → 繼續分析下一個假設
```

**代理工作**（每次迭代）：
1. 完整閱讀相關程式碼
2. 推演執行邏輯
3. 收集支持/反駁證據
4. 建立因果鏈
5. 做出判斷（確認/部分確認/排除）

**輸出**（每次迭代）：
- 假設驗證結果
- 詳細的邏輯分析
- 證據列表
- 信心度評分

**迭代控制**：
- 最多分析前 3-5 個假設
- 如果找到確認的 root cause，停止迭代
- 如果所有假設都被排除，報告需要更多資訊

**用戶交互**：
- 每次迭代後報告進度
- 如果假設被排除，說明原因並繼續
- 如果找到 root cause，展示完整分析

---

### 階段 4：驗證測試 [可選]

**觸發條件**：階段 3 找到確認的 root cause

**執行方式**：
```
詢問使用者：
"我已經定位到問題的根本原因。是否需要我創建一個簡單的測試案例來驗證和重現這個問題？"

選項：
- 是 → 設計並實作測試
- 否 → 跳到階段 5
```

**如果使用者選擇「是」**：
1. 基於 root cause 分析設計測試案例
2. 創建測試檔案或提供測試程式碼
3. 執行測試（如果環境允許）
4. 確認測試結果與預期一致

**測試類型**：
- **單元測試**：測試特定函式的邊界條件
- **整合測試**：測試完整的執行流程
- **手動測試腳本**：提供重現步驟

**用戶交互**：
- 詢問是否需要測試
- 展示測試程式碼
- 報告測試結果

---

### 階段 5：最終報告

**目標**：生成清晰、全面的問題分析報告

**報告內容**：
1. **執行摘要**
   - 問題簡述
   - Root cause 一句話總結
   - 修復建議概要

2. **問題分析**（來自階段 1）
   - 問題描述
   - 環境資訊
   - 影響範圍

3. **根本原因**（來自階段 3）
   - 詳細的 root cause 說明
   - 程式碼位置和行號
   - 完整的因果鏈
   - 為何是根本原因（邏輯分析）

4. **修復建議**
   - 推薦的修復方案（包含程式碼）
   - 修復優先級
   - 預期效果
   - 潛在副作用

5. **其他發現**
   - 次要問題列表
   - 程式碼品質觀察
   - 技術債務提醒

6. **驗證方法**
   - 如何驗證修復有效
   - 測試建議
   - 監控建議

7. **附錄**
   - 詳細的技術分析
   - 完整的程式碼片段
   - 參考資料

**報告格式**：
- 使用 Markdown 格式
- 清晰的章節劃分
- 程式碼使用語法高亮
- 使用表格和圖表（文字圖表）
- 行號引用格式：`file/path.ts:123`

**受眾考慮**：
- **非技術人員**（PM、使用者）：閱讀執行摘要
- **開發者**：閱讀根本原因和修復建議
- **技術主管**：閱讀完整報告

---

## 🎬 使用範例

### 範例 1：簡短的問題描述

**使用者輸入**：
```
使用者說他們提交訂單時頁面卡住了，有時候刷新後訂單有建立，有時候沒有。
```

**工作流程**：
```
[你] 我將使用 issue-review 技能來深入分析這個問題。

[階段 1] 啟動 problem-analyzer 代理...

[problem-analyzer 輸出]
問題分析報告：
- 問題類型：前端/後端整合問題
- 嚴重程度：High
- 初步假設：
  1. API 請求超時 (85%)
  2. Loading 狀態未重置 (70%)
  3. ...

[你] 問題分析完成。我發現了 3 個主要假設。現在開始調查程式碼庫...

[階段 2] 啟動 codebase-investigator 代理...

[codebase-investigator 輸出]
程式碼庫調查報告：
- 進入點：OrderForm.tsx:45
- 發現 7 個潛在問題點
- 可能原因排序：
  1. API 請求未設定 timeout (85/100)
  2. Loading 狀態未正確重置 (73/100)
  ...

[你] 程式碼調查完成。找到 5 個可能原因。現在開始驗證最高可能性的原因...

[階段 3-迭代 1] 啟動 root-cause-finder 代理分析原因 #1...

[root-cause-finder 輸出]
✅ Root Cause 已確認 (信心度: 96%)
- 位置：orderService.ts:34
- 問題：fetch() 未設定 timeout
- 完整因果鏈：[...]

[你] 🎉 根本原因已定位！

問題定位在 `src/services/orderService.ts:34`
fetch API 呼叫未設定 timeout，導致當伺服器回應緩慢時，請求永遠等待，使用者介面卡住。

是否需要我創建一個簡單的測試來驗證這個問題？(是/否)

[使用者] 是

[階段 4] 設計驗證測試...

[測試程式碼輸出]
...

[階段 5] 生成最終報告...

[完整報告輸出]
...

完成！問題分析報告已生成。
```

---

### 範例 2：詳細的錯誤報告

**使用者輸入**：
```
前端開發者反映：在用戶資料頁面，當使用者快速切換不同的分頁時，
偶爾會看到上一個分頁的資料閃現，然後才顯示正確的資料。
錯誤訊息：Warning: Can't perform a React state update on an unmounted component
環境：Chrome 120, React 18.2.0
```

**工作流程**：
```
[你] 這是一個詳細的錯誤報告。我將使用 issue-review 技能進行分析。

[階段 1] 啟動 problem-analyzer...

[分析結果]
- 問題類型：前端 - 狀態管理 / 非同步競態條件
- 嚴重程度：Medium
- 關鍵線索：
  1. 快速切換觸發
  2. React unmounted 警告
  3. 資料閃現（競態條件特徵）
- 初步假設：
  1. 元件卸載後仍嘗試更新狀態 (90%)
  2. 未清理的非同步請求 (85%)
  3. useEffect 清理函式缺失 (80%)

[階段 2] 啟動 codebase-investigator...

[調查結果]
- 進入點：UserProfilePage.tsx:23
- 發現問題：useEffect 中的 API 呼叫沒有清理函式
- 執行流程：[詳細流程圖]

[階段 3] 啟動 root-cause-finder...

[驗證結果]
✅ Root Cause 確認
- useEffect 缺少清理函式
- 快速切換時，前一個請求完成時元件已卸載
- 典型的 React 非同步競態條件問題

[最終報告]
...
```

---

## 🔄 特殊情況處理

### 情況 1：找不到確定的 Root Cause

**症狀**：
- 所有前 3 個假設都被排除
- 或所有假設都只是「部分確認」

**處理**：
1. 彙總所有「部分確認」的假設
2. 明確列出需要的額外資訊：
   - 需要的日誌
   - 需要的環境資訊
   - 需要使用者提供的重現步驟
3. 提供臨時建議：
   - 基於部分確認的假設的可能修復
   - 添加監控和日誌以收集更多資訊

**輸出範例**：
```markdown
## ⚠️ 無法確定唯一的 Root Cause

基於現有資訊，我識別出 3 個高可能性的原因，但都需要更多資訊才能確認：

1. **可能原因 A**（可能性 70%）
   - 描述：...
   - 需要：伺服器日誌驗證

2. **可能原因 B**（可能性 65%）
   - 描述：...
   - 需要：本地環境重現測試

## 建議下一步：
1. 收集 [具體資訊]
2. 執行 [具體測試]
3. 提供 [具體日誌]

收集到這些資訊後，我可以進一步分析並確定根本原因。
```

---

### 情況 2：多個並存的 Root Causes

**症狀**：
- 找到多個確認的 root causes
- 每個都能獨立導致問題
- 或它們共同作用導致問題

**處理**：
1. 識別所有確認的 root causes
2. 分析它們之間的關係：
   - 獨立並存
   - 共同作用
   - 主要 + 次要
3. 為每個 root cause 提供修復建議
4. 說明修復優先級

**輸出範例**：
```markdown
## 🎯 發現多個根本原因

這個問題由 **2 個獨立的 root causes** 共同導致：

### Root Cause #1（主要原因）
- 位置：...
- 問題：...
- 修復優先級：P0

### Root Cause #2（次要原因）
- 位置：...
- 問題：...
- 修復優先級：P1

## 修復策略
建議按順序修復：
1. 先修復 Root Cause #1（解決 80% 的問題）
2. 再修復 Root Cause #2（解決剩餘 20%）
```

---

### 情況 3：問題資訊極度缺乏

**症狀**：
- 問題描述只有一兩句話
- 無環境資訊
- 無重現步驟
- 無錯誤訊息

**處理**：
1. problem-analyzer 識別資訊缺口
2. 暫停工作流程
3. 向使用者詢問關鍵資訊

**輸出範例**：
```markdown
## ℹ️ 需要更多資訊

為了有效分析這個問題，我需要以下資訊：

### 必要資訊（至少提供 1-2 項）：
1. **錯誤訊息或堆疊追蹤**
2. **詳細的重現步驟**
3. **瀏覽器開發者工具的網路面板截圖**

### 有幫助的資訊：
4. 環境資訊（瀏覽器、版本）
5. 問題發生的時間和頻率
6. 是否所有使用者都受影響

請提供上述資訊後，我將繼續深入分析。

如果暫時無法提供這些資訊，我可以：
- 基於有限資訊提供最寬泛的調查方向
- 列出常見的可能原因
```

---

### 情況 4：問題已在新版本中修復

**症狀**：
- codebase-investigator 發現相關程式碼最近有修改
- 修改內容看起來已經解決了問題

**處理**：
1. root-cause-finder 確認修復
2. 說明問題已修復
3. 提供修復的提交資訊
4. 建議使用者升級版本

**輸出範例**：
```markdown
## ✅ 問題已在新版本中修復

經過分析，我發現這個問題已經在 **3 天前的提交** 中修復。

### 原始問題
- Root Cause：fetch() 未設定 timeout
- 位置：orderService.ts:34

### 修復資訊
- 提交：abc1234
- 日期：2025-XX-XX
- 作者：John Doe
- 提交訊息："Add timeout to order API calls"

### 建議
1. 確認生產環境是否已部署此修復
2. 如果未部署，請盡快部署
3. 部署後監控問題是否消失
```

---

## 💡 最佳實踐

### 1. 保持清晰的溝通
- 每個階段開始時告知使用者
- 展示進度（例如：「正在分析假設 2/5...」）
- 使用簡單語言解釋技術概念

### 2. 優先考慮效率
- 不要分析所有假設，找到確定的就停止
- 使用 TodoWrite 追蹤進度
- 並行操作時使用並行工具呼叫

### 3. 提供可操作的建議
- 不只找出問題，還要提供修復方案
- 包含具體的程式碼範例
- 說明如何驗證修復

### 4. 尊重不確定性
- 如果不確定，明確說明
- 標註信心度
- 提供替代假設

### 5. 全面但簡潔
- 最終報告要全面
- 但執行摘要要簡潔
- 使用分層結構

---

## 🎓 學習要點

使用者通過這個工作流程可以學習：

1. **系統化的問題診斷方法**
   - 如何從症狀分析到根本原因
   - 如何制定和驗證假設
   - 如何使用證據支持結論

2. **程式碼分析技巧**
   - 如何追蹤執行流程
   - 如何識別常見問題模式
   - 如何評估程式碼品質

3. **有效的技術溝通**
   - 如何結構化技術報告
   - 如何向不同受眾解釋技術問題
   - 如何提供可操作的建議

---

## 🚀 開始使用

現在你已經了解 Issue Review 工作流程，讓我們開始分析你的問題！

請提供：
1. **問題描述**：盡可能詳細的描述
2. **[可選] 環境資訊**：瀏覽器、版本、部署環境等
3. **[可選] 錯誤訊息**：錯誤日誌、堆疊追蹤等
4. **[可選] 重現步驟**：如何觸發這個問題

我將啟動系統化的分析流程，協助你找出問題的根本原因並提供解決方案！

---

**準備好了嗎？請提供你要分析的問題！** 🔍
